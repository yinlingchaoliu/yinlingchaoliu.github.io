import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as t,c as o,f as p}from"./app-CtvCwAmI.js";const a={},i=p(`<p>背景：随着软件规模的增大以及功能复杂性的提高，越来越有必要将单个应用拆分为独立的块、组件、模块或者插件。每个这样的部件都是模块化架构邮寄组成单元，而且每个部件都应该是独立的，并提供定义良好的对外接口供外部调用</p><p>模块化应用程序之于普通面向对象程序，相当于结构化编程之于意大利面条代码,都是为了避免GOTO效果</p><p><code>通过检查模块间依赖，可以评估一个应用架构的好坏</code></p><p>一个模块不依赖于另一个模块，显然该模块中类不会直接访问另一个模块中的类，这使得整个程序架构更加清晰，因为它有效避免无关代码部分之间类似GOTO的跳转</p><p>解决方案：</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>每个模块都应该对外提供公开的API
包之间避免不必要的交叉引用
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>只要代码开始访问其他无关模块中内容，那么技术架构退化就不可避免，从一开始就使用模块化思想进行设计，这才是王道</p><p>####1、模块化设计的类型 1、界面有关的代码就不需要提供对外API 2、提供简单但又非常通用的功能类库模块 3、考虑其他第三方基于该模块进行二次开发可能性（PDF文档支持） 4、模块化架构将规范与集体实现分离，分别放置不同模块中 5、通常采用模块化类库</p><p>####2、组件定位和交互 副标题：模块化架构中那些发现注入和依赖注入的模式</p><p>模块化目的实现一个程序中各组成部分的松耦合</p><p>依赖注入 （Spring）（Inversion of Control, IOC） 组件注入方案 1、配置 2、注解：通过注解标识JavaBean，将其注入，减少人工手写配置。（反射，编译性注解） 3、SerivceLoader 4、Lookup</p><p>选用Lookup理由 1、兼容各个版本JDK 2、lookup考虑动态性，当模块卸载有监听 3、Lookup提供两类API，一个为客户端代码服务，查询已注册服务，另一类API为开发者服务，方便编写服务池</p><p>####3、编写扩展点 配置Lookup 通过META-INF/serivces 注册实现类</p><p>####4、循环依赖的讨论 不容许出现出现循环依赖</p><p>####5、满城尽是Lookup 事件总线 Rxjava</p><p>####6、Lookup滥用 建议用作框架设计，而不是各处都采用</p>`,16),r=[i];function c(n,s){return t(),o("div",null,r)}const m=e(a,[["render",c],["__file","第7章-模块化架构.html.vue"]]),E=JSON.parse('{"path":"/basis/architect/%E8%BD%AF%E4%BB%B6%E6%A1%86%E6%9E%B6%E8%AE%BE%E8%AE%A1%E8%89%BA%E6%9C%AF/%E7%AC%AC7%E7%AB%A0-%E6%A8%A1%E5%9D%97%E5%8C%96%E6%9E%B6%E6%9E%84.html","title":"第7章-模块化架构","lang":"zh-CN","frontmatter":{"title":"第7章-模块化架构","date":"2024-03-24T11:47:50.000Z","category":["软件框架设计艺术"],"tag":["archive"],"description":"背景：随着软件规模的增大以及功能复杂性的提高，越来越有必要将单个应用拆分为独立的块、组件、模块或者插件。每个这样的部件都是模块化架构邮寄组成单元，而且每个部件都应该是独立的，并提供定义良好的对外接口供外部调用 模块化应用程序之于普通面向对象程序，相当于结构化编程之于意大利面条代码,都是为了避免GOTO效果 通过检查模块间依赖，可以评估一个应用架构的好坏...","head":[["meta",{"property":"og:url","content":"https://yinlingchaoliu.github.io/basis/architect/%E8%BD%AF%E4%BB%B6%E6%A1%86%E6%9E%B6%E8%AE%BE%E8%AE%A1%E8%89%BA%E6%9C%AF/%E7%AC%AC7%E7%AB%A0-%E6%A8%A1%E5%9D%97%E5%8C%96%E6%9E%B6%E6%9E%84.html"}],["meta",{"property":"og:site_name","content":"引领潮流"}],["meta",{"property":"og:title","content":"第7章-模块化架构"}],["meta",{"property":"og:description","content":"背景：随着软件规模的增大以及功能复杂性的提高，越来越有必要将单个应用拆分为独立的块、组件、模块或者插件。每个这样的部件都是模块化架构邮寄组成单元，而且每个部件都应该是独立的，并提供定义良好的对外接口供外部调用 模块化应用程序之于普通面向对象程序，相当于结构化编程之于意大利面条代码,都是为了避免GOTO效果 通过检查模块间依赖，可以评估一个应用架构的好坏..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-03-25T14:17:18.000Z"}],["meta",{"property":"article:author","content":"引领潮流"}],["meta",{"property":"article:tag","content":"archive"}],["meta",{"property":"article:published_time","content":"2024-03-24T11:47:50.000Z"}],["meta",{"property":"article:modified_time","content":"2024-03-25T14:17:18.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"第7章-模块化架构\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-03-24T11:47:50.000Z\\",\\"dateModified\\":\\"2024-03-25T14:17:18.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"引领潮流\\",\\"url\\":\\"https://www.jianshu.com/u/bdcce32c05dd\\"}]}"]]},"headers":[],"git":{"createdTime":1711376238000,"updatedTime":1711376238000,"contributors":[{"name":"引领潮流","email":"heat13@qq.com","commits":1}]},"readingTime":{"minutes":2.29,"words":686},"filePathRelative":"basis/architect/软件框架设计艺术/第7章-模块化架构.md","localizedDate":"2024年3月24日","excerpt":"<p>背景：随着软件规模的增大以及功能复杂性的提高，越来越有必要将单个应用拆分为独立的块、组件、模块或者插件。每个这样的部件都是模块化架构邮寄组成单元，而且每个部件都应该是独立的，并提供定义良好的对外接口供外部调用</p>\\n<p>模块化应用程序之于普通面向对象程序，相当于结构化编程之于意大利面条代码,都是为了避免GOTO效果</p>\\n<p><code>通过检查模块间依赖，可以评估一个应用架构的好坏</code></p>\\n<p>一个模块不依赖于另一个模块，显然该模块中类不会直接访问另一个模块中的类，这使得整个程序架构更加清晰，因为它有效避免无关代码部分之间类似GOTO的跳转</p>\\n<p>解决方案：</p>","autoDesc":true}');export{m as comp,E as data};
