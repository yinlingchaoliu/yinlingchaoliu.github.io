import{_ as a}from"./markword-D8LSzPfX.js";import{_ as n}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as e,c as i,f as s}from"./app-CtvCwAmI.js";const l="/assets/msi-DS_HtTDh.png",t="/assets/jmm-Cimdu8xS.png",p="/assets/threadstatus-B9EmUuoi.png",o="/assets/sync-BlpTuqyj.png",r={},c=s('<h3 id="java内存模型与线程" tabindex="-1"><a class="header-anchor" href="#java内存模型与线程"><span>java内存模型与线程</span></a></h3><h3 id="硬件效率与一致性" tabindex="-1"><a class="header-anchor" href="#硬件效率与一致性"><span>硬件效率与一致性</span></a></h3><figure><img src="'+l+'" alt="缓存一致性" tabindex="0" loading="lazy"><figcaption>缓存一致性</figcaption></figure><p>高速缓存的存储交互解决了处理器与内存的速度矛盾，但是它还是存在一致性问题，即缓存一致性。</p><p>多处理器有多个高速缓存(Cache)，他们共享同一主内存(Main Memory)</p><p>为了解决一致性问题，各个处理器访问缓存遵循协议 MSI MESI MOSI</p><p>本文”内存模型“，在特定操作协议下，对特定内存会高速缓存进行读写的过程抽象</p><p>为了使处理器运算单元利用率高，处理器对输入代码进行乱序执行优化(类java指令重新排序)</p><h3 id="java内存模型" tabindex="-1"><a class="header-anchor" href="#java内存模型"><span>java内存模型</span></a></h3><figure><img src="'+t+'" alt="jmm" tabindex="0" loading="lazy"><figcaption>jmm</figcaption></figure><h4 id="内存间交互操作" tabindex="-1"><a class="header-anchor" href="#内存间交互操作"><span>内存间交互操作</span></a></h4><ul><li>lock 锁定 主内存</li><li>unlock 解锁 主内存</li><li>read 读取 主内存</li><li>load 载入 工作内存</li><li>use 使用 工作内存</li><li>assign 赋值 工作内存</li><li>store 存储 工作内存</li><li>write 写入 主内存</li></ul><p>读取 read load 写入 store write</p><h4 id="long-double类型特殊规则" tabindex="-1"><a class="header-anchor" href="#long-double类型特殊规则"><span>long double类型特殊规则</span></a></h4><p>读写需要2条指令，非原子操作 根据虚拟机实现情况而定</p><h4 id="volatile特殊规则" tabindex="-1"><a class="header-anchor" href="#volatile特殊规则"><span>volatile特殊规则</span></a></h4><ol><li>可见性 volatile修饰变量 缓存中存在不一致性，但是每次使用之前都会从主内存中重新读取</li><li>禁止指令重新排序 指令 lock addl $0x0,(%esp) 内存屏障 禁止指令重排序</li></ol><h4 id="原则" tabindex="-1"><a class="header-anchor" href="#原则"><span>原则</span></a></h4><ol><li>原子性 原子性是指一个操作是不可分割的，要么全部执行，要么不执行</li><li>可见性 可见性是指一个线程修改了某个共享变量，其他线程能够立即看到这个修改</li><li>有序性 有序性是指线程按照代码的顺序执行</li><li>先行发生原则 操作A先发生于B，操作B可以观察到A的副作用</li></ol><h3 id="java与线程" tabindex="-1"><a class="header-anchor" href="#java与线程"><span>java与线程</span></a></h3><p>线程是比进程更轻量级调度执行单位，各个线程共享进程资源(内存地址,文件IO),又可以独立调度</p><p>Thread 关键实现是native方法,平台实现有关</p><h4 id="_1-使用内核线程实现" tabindex="-1"><a class="header-anchor" href="#_1-使用内核线程实现"><span>1. 使用内核线程实现</span></a></h4><p>操作系统内核线程实现，这种线程由内核来完成线程切换(不直接使用)</p><p>轻量级进程，就是通常所指的线程，每个轻量级线程都有一个内核进程支持，轻量级进程与内核进程1:1关系</p><p>每一个轻量级进程都是一个独立调度单元</p><p>缺点：1、轻量级线程操作，需要系统调用，需要用户态和内核态中来回切换 2、创建需要消耗内核资源，系统支持轻量级进程数量有限</p><h4 id="_2-使用用户线程实现" tabindex="-1"><a class="header-anchor" href="#_2-使用用户线程实现"><span>2. 使用用户线程实现</span></a></h4><p>一个线程只要不是内核线程，就可以任务用户进程</p><p>完全建立在用户空间的线程库 进程与用户线程是1:N关系</p><h4 id="_3-使用用户线程加轻量级进程混合实现" tabindex="-1"><a class="header-anchor" href="#_3-使用用户线程加轻量级进程混合实现"><span>3.使用用户线程加轻量级进程混合实现</span></a></h4><p>用户线程和轻量级进程比例 n:m</p><h4 id="_4-java线程的实现" tabindex="-1"><a class="header-anchor" href="#_4-java线程的实现"><span>4. java线程的实现</span></a></h4><p>虚拟机决定，采用线程api</p><h4 id="java线程调度" tabindex="-1"><a class="header-anchor" href="#java线程调度"><span>java线程调度</span></a></h4><p>同步式线程调度: 线程执行时间自己决定</p><p>抢占式线程调度:系统分配执行时间</p><h3 id="状态转换" tabindex="-1"><a class="header-anchor" href="#状态转换"><span>状态转换</span></a></h3><figure><img src="'+p+`" alt="线程状态转换" tabindex="0" loading="lazy"><figcaption>线程状态转换</figcaption></figure><ol><li>新建状态 new 线程刚创建，还没有启动</li><li>运行状态 runnable 线程已经启动。Ready 就绪状态 Running 运行状态</li><li>无限期等待 waitting 等待被显式唤起 object.wait() thread.join() LockSupport.park()</li><li>限期等待 Timed waitting 超时自动唤起 sleep(time) wait(time) join(time) LockSupport.parkNanos(time)</li><li>阻塞 blocked 线程阻塞了，等待一个锁资源</li><li>结束状态 terminated 线程结束</li></ol><h3 id="线程安全" tabindex="-1"><a class="header-anchor" href="#线程安全"><span>线程安全</span></a></h3><p>如果一个对象可以安全的被多个线程同时访问，那么这个对象就是线程安全的</p><p>多个线程访问同一个对象时，不需要额外的同步，调用这个对象行为都可以获得正确结果，那么是线程安全的</p><h4 id="不可变" tabindex="-1"><a class="header-anchor" href="#不可变"><span>不可变</span></a></h4><p>不可变对象被构建出来(没有发生this引用逃逸问题),是安全的</p><p>基本数据类型 使用final关键字修饰，保证它不可变，比如String Integer</p><h4 id="绝对线程安全" tabindex="-1"><a class="header-anchor" href="#绝对线程安全"><span>绝对线程安全</span></a></h4><p>任何情况下，无额外同步措施</p><p>原子操作组合业务，是非原子操作的，需要同步方法</p><h4 id="相对线程安全" tabindex="-1"><a class="header-anchor" href="#相对线程安全"><span>相对线程安全</span></a></h4><p>只保证这个对象单独操作是线程安全</p><h4 id="线程兼容" tabindex="-1"><a class="header-anchor" href="#线程兼容"><span>线程兼容</span></a></h4><p>调用方正确使用同步手段，保证现场对象在并发环境安全</p><h4 id="线程对立" tabindex="-1"><a class="header-anchor" href="#线程对立"><span>线程对立</span></a></h4><p>尝试停止和恢复另外线程来实现同步 resume suspend</p><h3 id="线程安全的实现" tabindex="-1"><a class="header-anchor" href="#线程安全的实现"><span>线程安全的实现</span></a></h3><h4 id="互斥同步" tabindex="-1"><a class="header-anchor" href="#互斥同步"><span>互斥同步</span></a></h4><p>互斥同步是指多个线程并发访问共享数据时，保证同一时刻只有一个线程使用，实现同步访问。互斥是实现同步的一种手段</p><p>synchronized关键字 ,关键字经过编译后，会在同步块生成monitorenter monitorexit指令,</p><ul><li><ol><li>字节码需要reference类型参数来指明锁定和解锁对象</li></ol></li><li><ol start="2"><li>执行moniter指令时，monitorenter 尝试获取对象锁，获得+1 没获得阻塞， monitorexit 释放对象锁，-1 计数器为0 释放</li></ol></li><li><ol start="3"><li>synchronized 可重入的</li></ol></li><li><ol start="4"><li>阻塞和唤醒一个线程，都需要操作系统从用户态切换到内核态，需要系统调用</li></ol></li></ul><p>ReentrantLock 实现同步</p><ul><li><ol><li>可重入</li></ol></li><li><ol start="2"><li>等待可中断： 持有锁线程长时间不释放，等待线程可以选择放弃等待</li></ol></li><li><ol start="3"><li>公平锁 按照申请锁顺序来依次获得锁 非公平锁 任何一个等待线程都可以获得锁</li></ol></li><li><ol start="4"><li>锁绑定多个条件 可以绑定多个condition</li></ol></li></ul><h4 id="非阻塞同步" tabindex="-1"><a class="header-anchor" href="#非阻塞同步"><span>非阻塞同步</span></a></h4><p>先进行操作，如果没有其他线程操作，则操作成功，否则失败，失败则重新进行操作</p><p>乐观锁</p><p>操作和冲突检测是原子性操作</p><ol><li>测试并射中</li><li>获取并增加</li><li>交换</li><li>比较并交换CAS</li><li>加载/存储</li></ol><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">incrementAndGet</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
      <span class="token keyword">int</span> cur <span class="token operator">=</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">int</span> next <span class="token operator">=</span> cur <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
      <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">compareAndSet</span><span class="token punctuation">(</span>cur<span class="token punctuation">,</span>next<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">return</span> next<span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
 <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>存在ABA问题 大部分场景不会影响并发安全性</p><h4 id="无同步方案" tabindex="-1"><a class="header-anchor" href="#无同步方案"><span>无同步方案</span></a></h4><ol><li><p>可重入代码</p></li><li><p>线程本地存储 ThreadLocal</p></li></ol><h3 id="锁优化" tabindex="-1"><a class="header-anchor" href="#锁优化"><span>锁优化</span></a></h3><h4 id="自旋锁与自适应自旋锁" tabindex="-1"><a class="header-anchor" href="#自旋锁与自适应自旋锁"><span>自旋锁与自适应自旋锁</span></a></h4><p>不放弃处理器执行时间，忙循环(自旋) 叫自旋锁 自适应自旋 , 自旋时间是由上一次状态决定</p><p>优点:避免线程切换开销 缺点消耗处理器资源</p><h4 id="锁消除" tabindex="-1"><a class="header-anchor" href="#锁消除"><span>锁消除</span></a></h4><p>移除没有同步需求的锁</p><h4 id="锁粗化" tabindex="-1"><a class="header-anchor" href="#锁粗化"><span>锁粗化</span></a></h4><p>频繁对一个对象中片段内容加锁，可以合并成一个锁，加到对象上</p><h3 id="锁升级" tabindex="-1"><a class="header-anchor" href="#锁升级"><span>锁升级</span></a></h3><h4 id="_0-对象头" tabindex="-1"><a class="header-anchor" href="#_0-对象头"><span>0.对象头</span></a></h4><figure><img src="`+a+'" alt="对象头" tabindex="0" loading="lazy"><figcaption>对象头</figcaption></figure><h4 id="_1-偏向锁" tabindex="-1"><a class="header-anchor" href="#_1-偏向锁"><span>1.偏向锁</span></a></h4><p>单线程尝试进入</p><p>加锁</p><ul><li>当锁对象第一次被线程获取时，jvm将对象头标志位设为”01“,即偏向模式</li><li>CAS操作 设置获得锁线程ID记录到对象头中，设置成功</li><li>持有偏向锁线程每次进入，不在有任何同步操作</li></ul><p>释放</p><ul><li>当有另外线程尝试获取这个锁，偏向模式结束</li><li>撤销偏向恢复未锁定，或升级轻量锁状态</li></ul><h4 id="_2-轻量锁" tabindex="-1"><a class="header-anchor" href="#_2-轻量锁"><span>2.轻量锁</span></a></h4><p>另外线程尝试获得锁</p><p>加锁</p><ul><li>线程创建锁记录(Lock Record)空间，用于存储锁对象</li><li>CAS操作 将对象MarkWord更新为Lock Record指针 称之为 Displaced MarkWord</li><li>更新锁状态为&quot;00&quot; 轻量锁 加锁成功</li></ul><p>膨胀</p><ul><li>加锁失败，如果markword指向当前线程执行栈帧 继续执行</li><li>否则，锁对象被强占，两个线程强占同一个锁，轻量锁失效</li><li>膨胀成重量锁，锁状态为&quot;10&quot;</li></ul><p>解锁</p><ul><li>将对象原来的MarkWord替换回来</li></ul><h4 id="_3-重量锁" tabindex="-1"><a class="header-anchor" href="#_3-重量锁"><span>3.重量锁</span></a></h4><p>多线程竞争锁</p><h4 id="锁升级流程" tabindex="-1"><a class="header-anchor" href="#锁升级流程"><span>锁升级流程</span></a></h4><figure><img src="'+o+'" alt="锁升级流程" tabindex="0" loading="lazy"><figcaption>锁升级流程</figcaption></figure>',100),d=[c];function h(u,m){return e(),i("div",null,d)}const k=n(r,[["render",h],["__file","8、java高效并发.html.vue"]]),b=JSON.parse('{"path":"/basis/jvm/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E8%99%9A%E6%8B%9F%E6%9C%BA/8%E3%80%81java%E9%AB%98%E6%95%88%E5%B9%B6%E5%8F%91.html","title":"8、java高效并发","lang":"zh-CN","frontmatter":{"title":"8、java高效并发","date":"2024-04-14T06:06:06.000Z","category":["深入理解java虚拟机"],"tag":["jvm"],"description":"java内存模型与线程 硬件效率与一致性 缓存一致性缓存一致性 高速缓存的存储交互解决了处理器与内存的速度矛盾，但是它还是存在一致性问题，即缓存一致性。 多处理器有多个高速缓存(Cache)，他们共享同一主内存(Main Memory) 为了解决一致性问题，各个处理器访问缓存遵循协议 MSI MESI MOSI 本文”内存模型“，在特定操作协议下，对特...","head":[["meta",{"property":"og:url","content":"https://yinlingchaoliu.github.io/basis/jvm/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E8%99%9A%E6%8B%9F%E6%9C%BA/8%E3%80%81java%E9%AB%98%E6%95%88%E5%B9%B6%E5%8F%91.html"}],["meta",{"property":"og:site_name","content":"引领潮流"}],["meta",{"property":"og:title","content":"8、java高效并发"}],["meta",{"property":"og:description","content":"java内存模型与线程 硬件效率与一致性 缓存一致性缓存一致性 高速缓存的存储交互解决了处理器与内存的速度矛盾，但是它还是存在一致性问题，即缓存一致性。 多处理器有多个高速缓存(Cache)，他们共享同一主内存(Main Memory) 为了解决一致性问题，各个处理器访问缓存遵循协议 MSI MESI MOSI 本文”内存模型“，在特定操作协议下，对特..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-04-15T06:12:27.000Z"}],["meta",{"property":"article:author","content":"引领潮流"}],["meta",{"property":"article:tag","content":"jvm"}],["meta",{"property":"article:published_time","content":"2024-04-14T06:06:06.000Z"}],["meta",{"property":"article:modified_time","content":"2024-04-15T06:12:27.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"8、java高效并发\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-04-14T06:06:06.000Z\\",\\"dateModified\\":\\"2024-04-15T06:12:27.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"引领潮流\\",\\"url\\":\\"https://www.jianshu.com/u/bdcce32c05dd\\"}]}"]]},"headers":[{"level":3,"title":"java内存模型与线程","slug":"java内存模型与线程","link":"#java内存模型与线程","children":[]},{"level":3,"title":"硬件效率与一致性","slug":"硬件效率与一致性","link":"#硬件效率与一致性","children":[]},{"level":3,"title":"java内存模型","slug":"java内存模型","link":"#java内存模型","children":[]},{"level":3,"title":"java与线程","slug":"java与线程","link":"#java与线程","children":[]},{"level":3,"title":"状态转换","slug":"状态转换","link":"#状态转换","children":[]},{"level":3,"title":"线程安全","slug":"线程安全","link":"#线程安全","children":[]},{"level":3,"title":"线程安全的实现","slug":"线程安全的实现","link":"#线程安全的实现","children":[]},{"level":3,"title":"锁优化","slug":"锁优化","link":"#锁优化","children":[]},{"level":3,"title":"锁升级","slug":"锁升级","link":"#锁升级","children":[]}],"git":{"createdTime":1712797641000,"updatedTime":1713161547000,"contributors":[{"name":"引领潮流","email":"heat13@qq.com","commits":4}]},"readingTime":{"minutes":6.73,"words":2019},"filePathRelative":"basis/jvm/深入理解java虚拟机/8、java高效并发.md","localizedDate":"2024年4月14日","excerpt":"<h3>java内存模型与线程</h3>\\n<h3>硬件效率与一致性</h3>\\n<figure><figcaption>缓存一致性</figcaption></figure>\\n<p>高速缓存的存储交互解决了处理器与内存的速度矛盾，但是它还是存在一致性问题，即缓存一致性。</p>\\n<p>多处理器有多个高速缓存(Cache)，他们共享同一主内存(Main Memory)</p>\\n<p>为了解决一致性问题，各个处理器访问缓存遵循协议 MSI MESI MOSI</p>\\n<p>本文”内存模型“，在特定操作协议下，对特定内存会高速缓存进行读写的过程抽象</p>\\n<p>为了使处理器运算单元利用率高，处理器对输入代码进行乱序执行优化(类java指令重新排序)</p>","autoDesc":true}');export{k as comp,b as data};
