import{_ as a}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as e,c as s,f as t}from"./app-CtvCwAmI.js";const i={},n=t(`<h4 id="_1、双亲委托模型" tabindex="-1"><a class="header-anchor" href="#_1、双亲委托模型"><span>1、双亲委托模型</span></a></h4><p>从java虚拟机角度讲，只存在两种类加载器 1、启动类加载器 BootstrapClassLoader，是C++语言实现 2、其他类加载器，java实现</p><p>从开发人员角度讲，划分三类 1、启动类加载器（BootstrapClassLoader） 负责加载JAVA_HOME/lib目录下或被-Xbootclasspath指定路径</p><p>2、扩展类加载器（ExtensionClassLoader） 负责加载&lt;JAVA_HOME&gt;\\lib\\ext</p><p>3、应用类加载器（ApplicationClassLoader） 负责加载用户类路径上的指定类库</p><figure><img src="https://upload-images.jianshu.io/upload_images/5526061-8c331cb3d0fb591a.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/1240" alt="双亲委托模型" tabindex="0" loading="lazy"><figcaption>双亲委托模型</figcaption></figure><p>类加载器之间父子关系是以组合关系来复用父加载器代码</p><p>双亲委托工作流程： 如果一个类加载器收到类加载请求，他首先不会自己尝试加载这个类，而是将这个请求委派给父类加载器完成，每一个层次加载器都是如此，直到委托到启动类加载器，只有父类反馈无法完成请求，子类才尝试加载</p><h4 id="_2、为什么使用双亲委托" tabindex="-1"><a class="header-anchor" href="#_2、为什么使用双亲委托"><span>2、为什么使用双亲委托</span></a></h4><p>1、因为可以避免重复加载，当父类已经加载该类，就没有必要让子类再加载一次。 2、考虑安全因素，如果用自定义同名类来动态替换java核心api中定义类型，存在非常大隐患，除非自定义ClassLoader搜索算法</p><h4 id="_3、jvm在搜索类中-如何判定两个class相同" tabindex="-1"><a class="header-anchor" href="#_3、jvm在搜索类中-如何判定两个class相同"><span>3、JVM在搜索类中，如何判定两个class相同</span></a></h4><p>1、判断两个类名是否相同 2、是否由同一个类加载器实例加载</p><h4 id="_4、代码实现" tabindex="-1"><a class="header-anchor" href="#_4、代码实现"><span>4、代码实现</span></a></h4><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>protected Class&lt;?&gt; loadClass(String className, boolean resolve) throws  ClassNotFoundException { 
    //首先检查类是否加载过
    Class&lt;?&gt; clazz = findLoadedClass(className);
    if (clazz == null) {   
        try {   
            //如果存在父节点，加载父加载器ClassLoader 
             if(parent!=null){
                 //如果没有加载过，先调用父加载器的loadClass
                 clazz = parent.loadClass(className, false);
             }else{//否则用启动类加载器
                  clazz= findBootstrapClassOrNull(className);
             }
        } catch (ClassNotFoundException e) {
            //抛出异常说明父类无法完成加载请求
            if(clazz == null){
                clazz = findClass(className);
            }
        }
    } 

    //解析class
    if(resolve){
        resolveClass(clazz)
    }

    return clazz;
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,14),l=[n];function o(r,d){return e(),s("div",null,l)}const m=a(i,[["render",o],["__file","双亲委托模型.html.vue"]]),v=JSON.parse('{"path":"/basis/advanced/%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%89%98%E6%A8%A1%E5%9E%8B.html","title":"双亲委托模型","lang":"zh-CN","frontmatter":{"title":"双亲委托模型","date":"2024-03-25T22:02:09.000Z","category":["知识进阶"],"tag":["archive"],"description":"1、双亲委托模型 从java虚拟机角度讲，只存在两种类加载器 1、启动类加载器 BootstrapClassLoader，是C++语言实现 2、其他类加载器，java实现 从开发人员角度讲，划分三类 1、启动类加载器（BootstrapClassLoader） 负责加载JAVA_HOME/lib目录下或被-Xbootclasspath指定路径 2、扩展...","head":[["meta",{"property":"og:url","content":"https://yinlingchaoliu.github.io/basis/advanced/%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%89%98%E6%A8%A1%E5%9E%8B.html"}],["meta",{"property":"og:site_name","content":"引领潮流"}],["meta",{"property":"og:title","content":"双亲委托模型"}],["meta",{"property":"og:description","content":"1、双亲委托模型 从java虚拟机角度讲，只存在两种类加载器 1、启动类加载器 BootstrapClassLoader，是C++语言实现 2、其他类加载器，java实现 从开发人员角度讲，划分三类 1、启动类加载器（BootstrapClassLoader） 负责加载JAVA_HOME/lib目录下或被-Xbootclasspath指定路径 2、扩展..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://upload-images.jianshu.io/upload_images/5526061-8c331cb3d0fb591a.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-03-26T09:37:40.000Z"}],["meta",{"property":"article:author","content":"引领潮流"}],["meta",{"property":"article:tag","content":"archive"}],["meta",{"property":"article:published_time","content":"2024-03-25T22:02:09.000Z"}],["meta",{"property":"article:modified_time","content":"2024-03-26T09:37:40.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"双亲委托模型\\",\\"image\\":[\\"https://upload-images.jianshu.io/upload_images/5526061-8c331cb3d0fb591a.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\\"],\\"datePublished\\":\\"2024-03-25T22:02:09.000Z\\",\\"dateModified\\":\\"2024-03-26T09:37:40.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"引领潮流\\",\\"url\\":\\"https://www.jianshu.com/u/bdcce32c05dd\\"}]}"]]},"headers":[],"git":{"createdTime":1711445860000,"updatedTime":1711445860000,"contributors":[{"name":"引领潮流","email":"heat13@qq.com","commits":1}]},"readingTime":{"minutes":1.77,"words":530},"filePathRelative":"basis/advanced/双亲委托模型.md","localizedDate":"2024年3月26日","excerpt":"<h4>1、双亲委托模型</h4>\\n<p>从java虚拟机角度讲，只存在两种类加载器\\n1、启动类加载器 BootstrapClassLoader，是C++语言实现\\n2、其他类加载器，java实现</p>\\n<p>从开发人员角度讲，划分三类\\n1、启动类加载器（BootstrapClassLoader）\\n负责加载JAVA_HOME/lib目录下或被-Xbootclasspath指定路径</p>\\n<p>2、扩展类加载器（ExtensionClassLoader）\\n负责加载&lt;JAVA_HOME&gt;\\\\lib\\\\ext</p>\\n<p>3、应用类加载器（ApplicationClassLoader）\\n负责加载用户类路径上的指定类库</p>","autoDesc":true}');export{m as comp,v as data};
