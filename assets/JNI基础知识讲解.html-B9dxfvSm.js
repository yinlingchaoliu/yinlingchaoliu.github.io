import{_ as n}from"./plugin-vue_export-helper-DlAUqK2U.js";import{r as i,o as r,c as l,a as t,b as a,d,f as s}from"./app-CtvCwAmI.js";const o={},c=t("p",null,"####目录",-1),p={href:"https://www.jianshu.com/p/f33988197f60",target:"_blank",rel:"noopener noreferrer"},v={href:"https://www.jianshu.com/p/c86dce5a70b0",target:"_blank",rel:"noopener noreferrer"},m={href:"https://www.jianshu.com/p/a4022db636d5",target:"_blank",rel:"noopener noreferrer"},b=s(`<p>####1、序言 学习ndk，就是为了更深入做图像识别，算法，人工智能领域 毕竟算法用C写保密性和效率比较好的，还是要将技术基本功再深入下去</p><p>C特点，处理字符串非常有优势，运行快，要充分利用</p><p>####2、开源demo https://github.com/yinlingchaoliu/HowToLearnNdk</p><p>####3、JNI与NDK区别和学习思路</p><ul><li><p>JNI 全称是 Java Native Interface，即 Java 本地接口。它是用来使得 Java 语言和 C/C++ 语言相互调用的</p></li><li><p>NDK 的全称是 Native Development Kit， 即C/C++开发工具包，它是用来做C/C++开发，提供了相关动态库</p></li><li><p>学习顺序 1)学习JNI 2)根据业务需求学习技术</p></li></ul><p>####4、常用概念 #####1、JNIEnv 声明native方法 建议用static修饰</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>public static native int plus(int a, int b);
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>快捷键生成对应方法</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>extern &quot;C&quot;
JNIEXPORT jint JNICALL
Java_com_glumes_myapplication_NativeClass_plus(JNIEnv *env, jobject instance, jint a, jint b) {
    jint sum = a + b;
    return sum;
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>JNIEnv 是 Java 虚拟机所运行的环境，通过它可以访问到 Java 虚拟机内部方法</p></li><li><p>2、类型对比</p></li></ul><p>基本数据类型</p><table><thead><tr><th>java类型</th><th>native类型</th></tr></thead><tbody><tr><td>boolean</td><td>jboolean</td></tr><tr><td>byte</td><td>jbyte</td></tr><tr><td>char</td><td>jchar</td></tr><tr><td>short</td><td>jshort</td></tr><tr><td>int</td><td>jnit</td></tr><tr><td>long</td><td>jlong</td></tr><tr><td>float</td><td>jfloat</td></tr><tr><td>double</td><td>jdouble</td></tr><tr><td>对应源码</td><td></td></tr></tbody></table><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>typedef uint8_t  jboolean; /* unsigned 8 bits */
typedef int8_t   jbyte;    /* signed 8 bits */
typedef uint16_t jchar;    /* unsigned 16 bits */
typedef int16_t  jshort;   /* signed 16 bits */
typedef int32_t  jint;     /* signed 32 bits */
typedef int64_t  jlong;    /* signed 64 bits */
typedef float    jfloat;   /* 32-bit IEEE 754 */
typedef double   jdouble;  /* 64-bit IEEE 754 */
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>引用数据类型</p><table><thead><tr><th>java类型</th><th>native类型</th></tr></thead><tbody><tr><td>All objects</td><td>jobject</td></tr><tr><td>java.lang.Class</td><td>jclass</td></tr><tr><td>java.lang.String</td><td>jstring</td></tr><tr><td>Object[]</td><td>jobjectArray</td></tr><tr><td>boolean[]</td><td>jbooleanArray</td></tr><tr><td>byte[]</td><td>jbyteArray</td></tr><tr><td>java.lang.Throwable</td><td>jthrowable</td></tr><tr><td>char[]</td><td>jcharArray</td></tr><tr><td>short[]</td><td>jshortArray</td></tr><tr><td>int[]</td><td>jintArray</td></tr><tr><td>long[]</td><td>jlongArray</td></tr><tr><td>float[]</td><td>jfloatArray</td></tr><tr><td>double[]</td><td>jdoubleArray</td></tr></tbody></table><p>jni操作，建议用基本数据类型和jstring</p><p>####String 字符串操作</p><ul><li>java默认使用Unicode 编码</li><li>C/C++默认使用UTF编码</li></ul><p>GetStringUTFChars(jstring string, jboolean* isCopy) 转换为UTF编码</p><p>GetStringChars(jstring string, jboolean* isCopy) 转换为Unicode编码</p><p>env结构体 有对应函数引用 方法说明不介绍 <img src="https://upload-images.jianshu.io/upload_images/5526061-98644241ba1f55c9.png?imageMogr2/auto-orient/strip|imageView2/2/w/1240" alt="字符串函数" loading="lazy"></p><p>#####数组操作</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>转换函数
intArray = env-&gt;GetIntArrayElements(intArray_, NULL);
env-&gt;ReleaseIntArrayElements(intArray_, intArray, 0);

GetTypeArrayRegion / SetTypeArrayRegion
GetArrayLength
GetPrimitiveArrayCritical / ReleasePrimitiveArrayCritical

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>JAVA与JNI签名转换</p><p>1、Java类中“.”换成“/” 2、“[”表示数组，“[”表示一维数组，“[[”表示二维数组 3、引用类型，大写字母“L”开头，“;”结尾 4、方法类型转换，先方法内，后返回参数 5 、中间无空格</p><table><thead><tr><th>示例</th><th></th></tr></thead><tbody><tr><td>Ljava/lang/String;</td><td>字符串</td></tr><tr><td>I</td><td>Int</td></tr><tr><td>[I</td><td>一维数组</td></tr><tr><td>[[I</td><td>二维数组</td></tr></tbody></table><p>java基础类型</p><table><thead><tr><th>java基础类型</th><th>JNI对应描述</th></tr></thead><tbody><tr><td>boolean</td><td>Z</td></tr><tr><td>byte</td><td>B</td></tr><tr><td>char</td><td>C</td></tr><tr><td>short</td><td>S</td></tr><tr><td>int</td><td>I</td></tr><tr><td>long</td><td>J</td></tr><tr><td>float</td><td>F</td></tr><tr><td>double</td><td>D</td></tr><tr><td>void</td><td>V</td></tr></tbody></table><p>引用类型转换</p><table><thead><tr><th>java引用类型</th><th>JNI对应描述转换</th></tr></thead><tbody><tr><td>String</td><td>Ljava/lang/String;</td></tr><tr><td>Class</td><td>Ljava/lang/Class;</td></tr><tr><td>Throwable</td><td>Ljava/lang/Throwable</td></tr><tr><td>int[]</td><td>[I</td></tr><tr><td>Object[]</td><td>[Ljava/lang/Object;</td></tr></tbody></table><p>方法签名转换</p><table><thead><tr><th>java类型</th><th>JNI对应描述转换</th></tr></thead><tbody><tr><td>String f();</td><td>()Ljava/lang/String;</td></tr><tr><td>long f(int i, Class c);</td><td>(ILjava/lang/Class;)J</td></tr><tr><td>String(byte[] bytes);</td><td>([B)V</td></tr></tbody></table><p>####JNI引用管理 #####1、局部引用 局部引用会阻止 GC 回收所引用的对象，同时，它不能在本地函数中跨函数传递，不能跨线程使用。</p><p>局部引用不能用static缓存 否则函数退出，局部引用被释放，static变量会成为一个野指针</p><p>申请内存函数 NewObject FindClass NewObjectArray ,new开头函数 采用DeleteLocalRef 手动回收</p><p>回收建议：不用要第一时间释放</p><p>局部引用函数</p><ul><li>EnsureLocalCapacity</li></ul><p>native方法 最少创建16个局部引用，复杂情况用EnsureLocalCapacity申请额外开销</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>int len = 20;
if (env-&gt;EnsureLocalCapacity(len) &lt; 0) {
  // 创建失败，out of memory
}

for (int i = 0; i &lt; len; ++i) {
    jstring  jstr = env-&gt;GetObjectArrayElement(arr,i);
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>PushLocalFrame &amp; PopLocalFrame配对使用 创建一个指定数量内嵌空间，在函数对之间局部引用都会在这个空间，释放后，这段空间内所有被释放掉 类似压栈出栈</li></ul><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>int len = 10;
if (env-&gt;PushLocalFrame(len)) { // 创建指定数据的局部引用空间
 //out ot memory
}

//中间各种局部引用代码
//todo
 jstring  jstr = env-&gt;GetObjectArrayElement(arr,i);
//中间各种局部引用代码
//中间各种局部引用代码

//弹出所有局部引用
env-&gt;PopLocalFrame(NULL); 
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>#####2、全局引用 全局引用和局部引用一样，也会阻止它所引用的对象被回收。但是它不会在方法返回时被自动释放，必须要通过手动释放才行，而且，全局引用可以跨方法、跨线程使用。</p><p>全局引用可以用static保存 NewGlobalRef DeleteGlobalRef</p><p>#####3、弱引用 弱全局引用有点类似于 Java 中的弱引用，它所引用的对象可以被 GC 回收，并且它也可以跨方法、跨线程使用。</p><p>isSameObject //监测 NewWeakGlobalRef //新建 DeleteWeakGlobalRef //删除</p><p>isSameObject其他用途</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>env-&gt;IsSameObject(obj1, obj2) // 比较局部引用 和 全局引用是否相同
env-&gt;IsSameObject(obj, NULL)  // 比较局部引用或者全局引用是否为 NULL
env-&gt;IsSameObject(wobj, NULL) // 比较弱全局引用所引用对象是否被 GC 回收
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>总结：局部引用最好用PushLocalFrame &amp; PopLocalFrame配对使用 NewLocalRef 可以保证返回一个局部引用</p>`,49);function u(g,h){const e=i("ExternalLinkIcon");return r(),l("div",null,[c,t("p",null,[t("a",p,[a("cmake快速实战"),d(e)])]),t("p",null,[t("a",v,[a("Android JNI基础知识讲解"),d(e)])]),t("p",null,[t("a",m,[a("Android JNI实战"),d(e)])]),b])}const f=n(o,[["render",u],["__file","JNI基础知识讲解.html.vue"]]),A=JSON.parse('{"path":"/fe/android/%E5%A6%82%E4%BD%95%E5%AD%A6%E4%B9%A0ndk/JNI%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E8%AE%B2%E8%A7%A3.html","title":"JNI基础知识讲解","lang":"zh-CN","frontmatter":{"title":"JNI基础知识讲解","date":"2024-03-24T11:47:50.000Z","category":["如何学习ndk"],"tag":["archive"],"description":"####目录 cmake快速实战 Android JNI基础知识讲解 Android JNI实战 ####1、序言 学习ndk，就是为了更深入做图像识别，算法，人工智能领域 毕竟算法用C写保密性和效率比较好的，还是要将技术基本功再深入下去 C特点，处理字符串非常有优势，运行快，要充分利用 ####2、开源demo https://github.com/...","head":[["meta",{"property":"og:url","content":"https://yinlingchaoliu.github.io/fe/android/%E5%A6%82%E4%BD%95%E5%AD%A6%E4%B9%A0ndk/JNI%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E8%AE%B2%E8%A7%A3.html"}],["meta",{"property":"og:site_name","content":"引领潮流"}],["meta",{"property":"og:title","content":"JNI基础知识讲解"}],["meta",{"property":"og:description","content":"####目录 cmake快速实战 Android JNI基础知识讲解 Android JNI实战 ####1、序言 学习ndk，就是为了更深入做图像识别，算法，人工智能领域 毕竟算法用C写保密性和效率比较好的，还是要将技术基本功再深入下去 C特点，处理字符串非常有优势，运行快，要充分利用 ####2、开源demo https://github.com/..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://upload-images.jianshu.io/upload_images/5526061-98644241ba1f55c9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-03-25T14:17:18.000Z"}],["meta",{"property":"article:author","content":"引领潮流"}],["meta",{"property":"article:tag","content":"archive"}],["meta",{"property":"article:published_time","content":"2024-03-24T11:47:50.000Z"}],["meta",{"property":"article:modified_time","content":"2024-03-25T14:17:18.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"JNI基础知识讲解\\",\\"image\\":[\\"https://upload-images.jianshu.io/upload_images/5526061-98644241ba1f55c9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\\"],\\"datePublished\\":\\"2024-03-24T11:47:50.000Z\\",\\"dateModified\\":\\"2024-03-25T14:17:18.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"引领潮流\\",\\"url\\":\\"https://www.jianshu.com/u/bdcce32c05dd\\"}]}"]]},"headers":[],"git":{"createdTime":1711376238000,"updatedTime":1711376238000,"contributors":[{"name":"引领潮流","email":"heat13@qq.com","commits":1}]},"readingTime":{"minutes":4.31,"words":1292},"filePathRelative":"fe/android/如何学习ndk/JNI基础知识讲解.md","localizedDate":"2024年3月24日","excerpt":"<p>####目录</p>\\n<p><a href=\\"https://www.jianshu.com/p/f33988197f60\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">cmake快速实战</a></p>\\n<p><a href=\\"https://www.jianshu.com/p/c86dce5a70b0\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">Android JNI基础知识讲解</a></p>\\n<p><a href=\\"https://www.jianshu.com/p/a4022db636d5\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">Android JNI实战</a></p>","autoDesc":true}');export{f as comp,A as data};
