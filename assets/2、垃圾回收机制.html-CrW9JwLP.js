import{_ as a}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as e,c as i,f as n}from"./app-CtvCwAmI.js";const t="/assets/gcRoot-CfzyOU6-.png",l="/assets/mark-sweep-JvH6Pz1w.png",r="/assets/copying-CRRh1ETt.png",s="/assets/mark-compact-D2WrdUIX.png",p="/assets/generational-collection-BHpI7aXk.png",o="/assets/collections-BZ2Q--nN.png",c={},h=n('<h3 id="_1标记算法" tabindex="-1"><a class="header-anchor" href="#_1标记算法"><span>1标记算法</span></a></h3><h4 id="_1-引用计数算法" tabindex="-1"><a class="header-anchor" href="#_1-引用计数算法"><span>1.引用计数算法</span></a></h4><p>每个对象都有一个引用计数器，当对象被引用+1 ，引用失效时就-1 ，当计数器为0时，则该对象设置为可回收的垃圾对象 循环引用，引用计数器失效</p><h4 id="_2-可达性分析算法" tabindex="-1"><a class="header-anchor" href="#_2-可达性分析算法"><span>2.可达性分析算法</span></a></h4><p>GC Roots对象作为起始点，从GC Roots开始向下搜索，搜索走过的路径叫引用链，当一个对象没有引用链，则该对象不可达，可回收</p><figure><img src="'+t+'" alt="可达性分析" tabindex="0" loading="lazy"><figcaption>可达性分析</figcaption></figure><p>gcRoot对象</p><ul><li>虚拟机栈中引用对象</li><li>本地方法栈中引用对象</li><li>方法区中类静态属性引用对象</li><li>方法区中常量引用对象</li></ul><h4 id="_3-四种引用" tabindex="-1"><a class="header-anchor" href="#_3-四种引用"><span>3.四种引用</span></a></h4><ul><li>强引用: 只要强引用存在，垃圾回收器就不会回收该对象 strongReference</li><li>软引用: 当内存不足时，垃圾回收器会回收该对象 SoftReference</li><li>弱引用: 被弱引用关联对象只能生存到下一次垃圾收集发生之前 WeakReference</li><li>虚引用：最弱引用，对象被收集器回收时收到一个系统通知 PhantomReference</li></ul><h4 id="_4-回收过程" tabindex="-1"><a class="header-anchor" href="#_4-回收过程"><span>4.回收过程</span></a></h4><ol><li>对象不可达</li><li>第一次标记筛选，检测对象不可达，有必要执行finalize方法，放入F-Queue队列</li><li>第二次标记筛选，检测对象不可达，从F-Queue队列中取出，执行finalize方法</li></ol><p>finalize方法回收垃圾不建议，建议try-finally</p><h4 id="_5-回收方法区" tabindex="-1"><a class="header-anchor" href="#_5-回收方法区"><span>5. 回收方法区</span></a></h4><p>在永久代回收，性价比不高 回收内容：废弃常量和无用的类</p><p>无用类判断标准，满足仅代表可以回收，但不一定</p><ul><li>该类所有实例已被回收</li><li>加载该类classloader被回收</li><li>该类对应的对象没有被任何地方被引用</li></ul><h3 id="_2-收集算法" tabindex="-1"><a class="header-anchor" href="#_2-收集算法"><span>2.收集算法</span></a></h3><h4 id="_1-标记-清除算法" tabindex="-1"><a class="header-anchor" href="#_1-标记-清除算法"><span>1.标记-清除算法</span></a></h4><p>首先标记所有需要回收的对象，然后统一回收所有标记对象</p><figure><img src="'+l+'" alt="标记-清除算法" tabindex="0" loading="lazy"><figcaption>标记-清除算法</figcaption></figure><p>缺点：</p><ul><li>效率问题：标记和清除两个过程效率不高</li><li>空间问题：产生大量不连续内存碎片</li></ul><h4 id="_2-复制算法" tabindex="-1"><a class="header-anchor" href="#_2-复制算法"><span>2.复制算法</span></a></h4><p>先把内存一分为二，每次只使用其中一个区域，垃圾回收时，将存活的对象全部拷贝到另外一个区域，然后对之前的区域进行全部回收</p><figure><img src="'+r+'" alt="复制算法" tabindex="0" loading="lazy"><figcaption>复制算法</figcaption></figure><p>商业场景中 Eden:Sur0:Sur1 = 8:1:1</p><p>优点是高效 缺点是有一部分空间未利用，当存活对象变多时，效率会降低</p><h4 id="_3-标记-整理算法" tabindex="-1"><a class="header-anchor" href="#_3-标记-整理算法"><span>3.标记-整理算法</span></a></h4><p>让存活的对象都向一端移动，清理掉端边界外的内存</p><figure><img src="'+s+'" alt="标记-整理算法" tabindex="0" loading="lazy"><figcaption>标记-整理算法</figcaption></figure><p>缺点:耗时</p><h4 id="_4-分代收集算法" tabindex="-1"><a class="header-anchor" href="#_4-分代收集算法"><span>4.分代收集算法</span></a></h4><p>根据对象存活周期划分：新生代、老年代、持久代</p><p>年轻代：复制算法 老年代，标记-整理算法 或 标记-清除算法</p><figure><img src="'+p+'" alt="分代收集算法" tabindex="0" loading="lazy"><figcaption>分代收集算法</figcaption></figure><h3 id="_3-算法实现" tabindex="-1"><a class="header-anchor" href="#_3-算法实现"><span>3.算法实现</span></a></h3><h4 id="_1-枚举根节点" tabindex="-1"><a class="header-anchor" href="#_1-枚举根节点"><span>1.枚举根节点</span></a></h4><p>枚举根节点过程中，对象的引用关系不能发生变化，否则分析结果不能保证，这点导致GC进行时必须停顿所有java线程(Stop The World) STW 采用准确式gc,不需要遍历所有，采用OopMap数据结构达成目标</p><h4 id="_2-安全点" tabindex="-1"><a class="header-anchor" href="#_2-安全点"><span>2.安全点</span></a></h4><p>程序只有到达安全点，才能gc。 在方法调用，循环跳转、异常跳转等，才会产生安全点，考虑是让程序长时间执行</p><p>如何让线程跑到安全点，在进入gc问题</p><ul><li>抢占式中断：先把所有线程全部中断，发现不在安全点线程，恢复运行到安全点再中断</li><li>主动式中断：不直接操作线程，直接设置中断标志，线程自己运行到标志，自己中断挂起</li></ul><h4 id="_3-安全区域" tabindex="-1"><a class="header-anchor" href="#_3-安全区域"><span>3.安全区域</span></a></h4><p>解决未分配CPU时间，走到安全点挂起。 扩大了安全范围</p><h3 id="_4-垃圾收集器" tabindex="-1"><a class="header-anchor" href="#_4-垃圾收集器"><span>4.垃圾收集器</span></a></h3><figure><img src="'+o+'" alt="垃圾收集器" tabindex="0" loading="lazy"><figcaption>垃圾收集器</figcaption></figure><h4 id="serial-收集器" tabindex="-1"><a class="header-anchor" href="#serial-收集器"><span>Serial 收集器</span></a></h4><p>进行垃圾收集时，必须暂停其他工作线程，直到它收集结束(STW)</p><p>简单高效，应用场景客户端桌面 单CPU场景下</p><h4 id="parnew-收集器" tabindex="-1"><a class="header-anchor" href="#parnew-收集器"><span>ParNew 收集器</span></a></h4><p>Serial收集器多线程版本</p><p>多CPU场景下较好</p><h4 id="parallel-scavenge-收集器" tabindex="-1"><a class="header-anchor" href="#parallel-scavenge-收集器"><span>Parallel Scavenge 收集器</span></a></h4><p>ParNew收集器多线程版本，关注点在吞吐量优先</p><h4 id="serial-old-收集器" tabindex="-1"><a class="header-anchor" href="#serial-old-收集器"><span>serial Old 收集器</span></a></h4><p>Serial的老年代版本，单线程收集器</p><h4 id="parallel-old-收集器" tabindex="-1"><a class="header-anchor" href="#parallel-old-收集器"><span>Parallel Old 收集器</span></a></h4><p>Parallel Scavenge收集器老年版本，吞吐量优先</p><h4 id="cms收集器" tabindex="-1"><a class="header-anchor" href="#cms收集器"><span>CMS收集器</span></a></h4><p>最短时间停顿收集器，关注点在响应时间优先 并发收集，低停顿</p><p>标记-清除算法，会造成大量内存碎片，空间效率低</p><h4 id="g1收集器" tabindex="-1"><a class="header-anchor" href="#g1收集器"><span>G1收集器</span></a></h4><p>1、并发并行 2、分代收集 3、空间整合：整体是标记-整理，局部是复制算法 4、可预测的停顿</p><h3 id="_5-内存分配和回收策略" tabindex="-1"><a class="header-anchor" href="#_5-内存分配和回收策略"><span>5.内存分配和回收策略</span></a></h3><ol><li>对象优先分配在Eden区</li><li>大对象直接进入老年代 (朝生夕死大对象应该避免)</li><li>长期存活的对象进入老年代 (15岁，安卓8.0后，永久代被移除6岁) MinorGC</li><li>动态年龄判断，相同年龄对象大小之和&gt;survivor空间大小，则进入老年代</li><li>空间分配担保 MinorGC 查看老年代最大连续空间&gt;新生代对象之和，否则触发FullGC</li></ol>',66),d=[h];function g(_,f){return e(),i("div",null,d)}const b=a(c,[["render",g],["__file","2、垃圾回收机制.html.vue"]]),E=JSON.parse('{"path":"/basis/jvm/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E8%99%9A%E6%8B%9F%E6%9C%BA/2%E3%80%81%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6.html","title":"2、垃圾回收机制","lang":"zh-CN","frontmatter":{"title":"2、垃圾回收机制","date":"2024-04-10T06:06:06.000Z","category":["深入理解java虚拟机"],"tag":["jvm"],"description":"1标记算法 1.引用计数算法 每个对象都有一个引用计数器，当对象被引用+1 ，引用失效时就-1 ，当计数器为0时，则该对象设置为可回收的垃圾对象 循环引用，引用计数器失效 2.可达性分析算法 GC Roots对象作为起始点，从GC Roots开始向下搜索，搜索走过的路径叫引用链，当一个对象没有引用链，则该对象不可达，可回收 可达性分析可达性分析 gcR...","head":[["meta",{"property":"og:url","content":"https://yinlingchaoliu.github.io/basis/jvm/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E8%99%9A%E6%8B%9F%E6%9C%BA/2%E3%80%81%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6.html"}],["meta",{"property":"og:site_name","content":"引领潮流"}],["meta",{"property":"og:title","content":"2、垃圾回收机制"}],["meta",{"property":"og:description","content":"1标记算法 1.引用计数算法 每个对象都有一个引用计数器，当对象被引用+1 ，引用失效时就-1 ，当计数器为0时，则该对象设置为可回收的垃圾对象 循环引用，引用计数器失效 2.可达性分析算法 GC Roots对象作为起始点，从GC Roots开始向下搜索，搜索走过的路径叫引用链，当一个对象没有引用链，则该对象不可达，可回收 可达性分析可达性分析 gcR..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-04-11T04:54:05.000Z"}],["meta",{"property":"article:author","content":"引领潮流"}],["meta",{"property":"article:tag","content":"jvm"}],["meta",{"property":"article:published_time","content":"2024-04-10T06:06:06.000Z"}],["meta",{"property":"article:modified_time","content":"2024-04-11T04:54:05.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"2、垃圾回收机制\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-04-10T06:06:06.000Z\\",\\"dateModified\\":\\"2024-04-11T04:54:05.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"引领潮流\\",\\"url\\":\\"https://www.jianshu.com/u/bdcce32c05dd\\"}]}"]]},"headers":[{"level":3,"title":"1标记算法","slug":"_1标记算法","link":"#_1标记算法","children":[]},{"level":3,"title":"2.收集算法","slug":"_2-收集算法","link":"#_2-收集算法","children":[]},{"level":3,"title":"3.算法实现","slug":"_3-算法实现","link":"#_3-算法实现","children":[]},{"level":3,"title":"4.垃圾收集器","slug":"_4-垃圾收集器","link":"#_4-垃圾收集器","children":[]},{"level":3,"title":"5.内存分配和回收策略","slug":"_5-内存分配和回收策略","link":"#_5-内存分配和回收策略","children":[]}],"git":{"createdTime":1712797641000,"updatedTime":1712811245000,"contributors":[{"name":"引领潮流","email":"heat13@qq.com","commits":2}]},"readingTime":{"minutes":4.55,"words":1365},"filePathRelative":"basis/jvm/深入理解java虚拟机/2、垃圾回收机制.md","localizedDate":"2024年4月10日","excerpt":"<h3>1标记算法</h3>\\n<h4>1.引用计数算法</h4>\\n<p>每个对象都有一个引用计数器，当对象被引用+1 ，引用失效时就-1 ，当计数器为0时，则该对象设置为可回收的垃圾对象\\n循环引用，引用计数器失效</p>\\n<h4>2.可达性分析算法</h4>\\n<p>GC Roots对象作为起始点，从GC Roots开始向下搜索，搜索走过的路径叫引用链，当一个对象没有引用链，则该对象不可达，可回收</p>\\n<figure><figcaption>可达性分析</figcaption></figure>\\n<p>gcRoot对象</p>\\n<ul>\\n<li>虚拟机栈中引用对象</li>\\n<li>本地方法栈中引用对象</li>\\n<li>方法区中类静态属性引用对象</li>\\n<li>方法区中常量引用对象</li>\\n</ul>","autoDesc":true}');export{b as comp,E as data};
