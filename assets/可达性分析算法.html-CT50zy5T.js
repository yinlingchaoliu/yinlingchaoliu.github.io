import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o,c as a,a as t}from"./app-CtvCwAmI.js";const n={},i=t("p",null,"可达性分析算法通过一系列成为GCRoots的对象作为起始点，从这些节点上向下搜索，所走过的路径称为引用链，当一个对象没有任何引用链与GCRoots连接时就说明此对象不可用，也就是对象不可达",-1),r=t("p",null,"GCRoots对象 1、虚拟机栈中引用对象（栈帧中本地变量表） 2、方法中类的静态属性引用对象 3、方法区中常量引用对象 4、native方法引用的对象",-1),c=t("p",null,"可达性分析算法整个清理流程 1、第一次标记：对象经过可达性分析，没有GCRoots引用链,则进行第一次标记筛选，筛选条件是：该对象是否必要执行finalize()方法：没有覆盖finalize方法或该方法已经执行过。如果有必要执行，则该对象放在F-Queue队列，并稍后在由虚拟 机建立的低优先级 Finalizer 线程中触发该对象的 finalize()方法，但不保证一定等 待它执行结束。 2、第二次标记:GC 对 F-Queue 队列里的对象进行第二次标记，如果在第二次标记 时该对象又成功被引用，则会被移除即将回收的集合，否则会被回收",-1),s=t("p",null,"注意：任何一个对象finalize方法只会被系统调用一次",-1),p=[i,r,c,s];function l(d,m){return o(),a("div",null,p)}const h=e(n,[["render",l],["__file","可达性分析算法.html.vue"]]),E=JSON.parse('{"path":"/basis/advanced/%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90%E7%AE%97%E6%B3%95.html","title":"可达性分析算法","lang":"zh-CN","frontmatter":{"title":"可达性分析算法","date":"2024-03-25T22:02:09.000Z","category":["知识进阶"],"tag":["archive"],"description":"可达性分析算法通过一系列成为GCRoots的对象作为起始点，从这些节点上向下搜索，所走过的路径称为引用链，当一个对象没有任何引用链与GCRoots连接时就说明此对象不可用，也就是对象不可达 GCRoots对象 1、虚拟机栈中引用对象（栈帧中本地变量表） 2、方法中类的静态属性引用对象 3、方法区中常量引用对象 4、native方法引用的对象 可达性分析...","head":[["meta",{"property":"og:url","content":"https://yinlingchaoliu.github.io/basis/advanced/%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90%E7%AE%97%E6%B3%95.html"}],["meta",{"property":"og:site_name","content":"引领潮流"}],["meta",{"property":"og:title","content":"可达性分析算法"}],["meta",{"property":"og:description","content":"可达性分析算法通过一系列成为GCRoots的对象作为起始点，从这些节点上向下搜索，所走过的路径称为引用链，当一个对象没有任何引用链与GCRoots连接时就说明此对象不可用，也就是对象不可达 GCRoots对象 1、虚拟机栈中引用对象（栈帧中本地变量表） 2、方法中类的静态属性引用对象 3、方法区中常量引用对象 4、native方法引用的对象 可达性分析..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-03-26T09:37:40.000Z"}],["meta",{"property":"article:author","content":"引领潮流"}],["meta",{"property":"article:tag","content":"archive"}],["meta",{"property":"article:published_time","content":"2024-03-25T22:02:09.000Z"}],["meta",{"property":"article:modified_time","content":"2024-03-26T09:37:40.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"可达性分析算法\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-03-25T22:02:09.000Z\\",\\"dateModified\\":\\"2024-03-26T09:37:40.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"引领潮流\\",\\"url\\":\\"https://www.jianshu.com/u/bdcce32c05dd\\"}]}"]]},"headers":[],"git":{"createdTime":1711445860000,"updatedTime":1711445860000,"contributors":[{"name":"引领潮流","email":"heat13@qq.com","commits":1}]},"readingTime":{"minutes":1.23,"words":369},"filePathRelative":"basis/advanced/可达性分析算法.md","localizedDate":"2024年3月26日","excerpt":"<p>可达性分析算法通过一系列成为GCRoots的对象作为起始点，从这些节点上向下搜索，所走过的路径称为引用链，当一个对象没有任何引用链与GCRoots连接时就说明此对象不可用，也就是对象不可达</p>\\n<p>GCRoots对象\\n1、虚拟机栈中引用对象（栈帧中本地变量表）\\n2、方法中类的静态属性引用对象\\n3、方法区中常量引用对象\\n4、native方法引用的对象</p>\\n<p>可达性分析算法整个清理流程\\n1、第一次标记：对象经过可达性分析，没有GCRoots引用链,则进行第一次标记筛选，筛选条件是：该对象是否必要执行finalize()方法：没有覆盖finalize方法或该方法已经执行过。如果有必要执行，则该对象放在F-Queue队列，并稍后在由虚拟 机建立的低优先级 Finalizer 线程中触发该对象的 finalize()方法，但不保证一定等 待它执行结束。\\n2、第二次标记:GC 对 F-Queue 队列里的对象进行第二次标记，如果在第二次标记 时该对象又成功被引用，则会被移除即将回收的集合，否则会被回收</p>","autoDesc":true}');export{h as comp,E as data};
