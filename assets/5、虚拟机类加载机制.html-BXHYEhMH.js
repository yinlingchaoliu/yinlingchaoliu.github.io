import{_ as a}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as n,c as s,f as t}from"./app-CtvCwAmI.js";const e="/assets/loading-DwYxND-E.png",p={},i=t('<h3 id="类加载时机" tabindex="-1"><a class="header-anchor" href="#类加载时机"><span>类加载时机</span></a></h3><figure><img src="'+e+`" alt="类加载的时机" tabindex="0" loading="lazy"><figcaption>类加载的时机</figcaption></figure><p>加载、验证、准备、初始化 顺序是固定的</p><p>必须初始化5种情况</p><ul><li>遇到 new getstatic、invokestatic putstatic、4条指令</li><li>Reflect包进行反射时</li><li>初始化一个类，父类未初始化时</li><li>Main类</li><li>动态支持，解析结果REF_getstatic、REF_putstatic、REF_invokeStatic方法句柄</li></ul><h4 id="加载" tabindex="-1"><a class="header-anchor" href="#加载"><span>加载</span></a></h4><ol><li>读取二进制字节流.class</li><li>解析方法区运行时数据结构 .classfile</li><li>内存生成java.lang.Class对象</li></ol><h4 id="验证" tabindex="-1"><a class="header-anchor" href="#验证"><span>验证</span></a></h4><ol><li>验证文件格式</li><li>元数据验证</li><li>字节码验证</li></ol><h4 id="准备" tabindex="-1"><a class="header-anchor" href="#准备"><span>准备</span></a></h4><p>给类变量分配内存并设置初始值</p><h4 id="解析" tabindex="-1"><a class="header-anchor" href="#解析"><span>解析</span></a></h4><p>常量池内的符号替换成直接引用过程</p><ol><li>类或接口的解析</li><li>字段的解析</li><li>类方法的解析</li><li>接口方法的解析</li></ol><h4 id="初始化" tabindex="-1"><a class="header-anchor" href="#初始化"><span>初始化</span></a></h4><p>init</p><h3 id="双亲委派模型" tabindex="-1"><a class="header-anchor" href="#双亲委派模型"><span>双亲委派模型</span></a></h3><ol><li>启动类加载器 Bootstrap ClassLoader C++ 虚拟机一部分</li><li>扩展类加载器 Extension ClassLoader java独立于虚拟机外部</li><li>应用类加载器 App ClassLoader</li><li>自定义类加载器</li></ol><p>类加载器的层次关系，称之为双亲委派模型</p><p>双亲委派模型工作过程</p><p>如果一个类加载器收到加载请求, 首先不会自己尝试加载这个类，而是委派到它的父类加载器去尝试加载，每层都如此，直到顶层的启动类加载器，直到父加载器反馈无法完成，子加载器才会尝试自己加载</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">protected</span> <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> <span class="token function">loadClass</span><span class="token punctuation">(</span><span class="token class-name">String</span> className<span class="token punctuation">,</span> <span class="token keyword">boolean</span> resolve<span class="token punctuation">)</span> 
    <span class="token keyword">throws</span>  <span class="token class-name">ClassNotFoundException</span> <span class="token punctuation">{</span> 
    <span class="token comment">//首先检查类是否加载过</span>
    <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> clazz <span class="token operator">=</span> <span class="token function">findLoadedClass</span><span class="token punctuation">(</span>className<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>clazz <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   
        <span class="token keyword">try</span> <span class="token punctuation">{</span>   
            <span class="token comment">//如果存在父节点，加载父加载器ClassLoader </span>
             <span class="token keyword">if</span><span class="token punctuation">(</span>parent<span class="token operator">!=</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                 <span class="token comment">//如果没有加载过，先调用父加载器的loadClass</span>
                 clazz <span class="token operator">=</span> parent<span class="token punctuation">.</span><span class="token function">loadClass</span><span class="token punctuation">(</span>className<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
             <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span><span class="token comment">//否则用启动类加载器</span>
                  clazz<span class="token operator">=</span> <span class="token function">findBootstrapClassOrNull</span><span class="token punctuation">(</span>className<span class="token punctuation">)</span><span class="token punctuation">;</span>
             <span class="token punctuation">}</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ClassNotFoundException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">//抛出异常说明父类无法完成加载请求</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>clazz <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                clazz <span class="token operator">=</span> <span class="token function">findClass</span><span class="token punctuation">(</span>className<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span> 

    <span class="token comment">//解析class</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>resolve<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token function">resolveClass</span><span class="token punctuation">(</span>clazz<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> clazz<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="为什么使用双亲委托" tabindex="-1"><a class="header-anchor" href="#为什么使用双亲委托"><span>为什么使用双亲委托</span></a></h4><p>1、因为可以避免重复加载，当父类已经加载该类，就没有必要让子类再加载一次。</p><p>2、考虑安全因素，如果用自定义同名类来动态替换java核心api中定义类型，存在非常大隐患，除非自定义ClassLoader搜索算法</p><h4 id="jvm在搜索类中-如何判定两个class相同" tabindex="-1"><a class="header-anchor" href="#jvm在搜索类中-如何判定两个class相同"><span>JVM在搜索类中，如何判定两个class相同</span></a></h4><p>1、判断两个类名是否相同</p><p>2、是否由同一个类加载器实例加载</p>`,28),l=[i];function c(o,r){return n(),s("div",null,l)}const k=a(p,[["render",c],["__file","5、虚拟机类加载机制.html.vue"]]),m=JSON.parse('{"path":"/basis/jvm/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E8%99%9A%E6%8B%9F%E6%9C%BA/5%E3%80%81%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6.html","title":"5、虚拟机类加载机制","lang":"zh-CN","frontmatter":{"title":"5、虚拟机类加载机制","date":"2024-04-10T06:06:06.000Z","category":["深入理解java虚拟机"],"tag":["jvm"],"description":"类加载时机 类加载的时机类加载的时机 加载、验证、准备、初始化 顺序是固定的 必须初始化5种情况 遇到 new getstatic、invokestatic putstatic、4条指令 Reflect包进行反射时 初始化一个类，父类未初始化时 Main类 动态支持，解析结果REF_getstatic、REF_putstatic、REF_invokeS...","head":[["meta",{"property":"og:url","content":"https://yinlingchaoliu.github.io/basis/jvm/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E8%99%9A%E6%8B%9F%E6%9C%BA/5%E3%80%81%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6.html"}],["meta",{"property":"og:site_name","content":"引领潮流"}],["meta",{"property":"og:title","content":"5、虚拟机类加载机制"}],["meta",{"property":"og:description","content":"类加载时机 类加载的时机类加载的时机 加载、验证、准备、初始化 顺序是固定的 必须初始化5种情况 遇到 new getstatic、invokestatic putstatic、4条指令 Reflect包进行反射时 初始化一个类，父类未初始化时 Main类 动态支持，解析结果REF_getstatic、REF_putstatic、REF_invokeS..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-04-12T03:01:58.000Z"}],["meta",{"property":"article:author","content":"引领潮流"}],["meta",{"property":"article:tag","content":"jvm"}],["meta",{"property":"article:published_time","content":"2024-04-10T06:06:06.000Z"}],["meta",{"property":"article:modified_time","content":"2024-04-12T03:01:58.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"5、虚拟机类加载机制\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-04-10T06:06:06.000Z\\",\\"dateModified\\":\\"2024-04-12T03:01:58.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"引领潮流\\",\\"url\\":\\"https://www.jianshu.com/u/bdcce32c05dd\\"}]}"]]},"headers":[{"level":3,"title":"类加载时机","slug":"类加载时机","link":"#类加载时机","children":[]},{"level":3,"title":"双亲委派模型","slug":"双亲委派模型","link":"#双亲委派模型","children":[]}],"git":{"createdTime":1712797641000,"updatedTime":1712890918000,"contributors":[{"name":"引领潮流","email":"heat13@qq.com","commits":4}]},"readingTime":{"minutes":2.17,"words":650},"filePathRelative":"basis/jvm/深入理解java虚拟机/5、虚拟机类加载机制.md","localizedDate":"2024年4月10日","excerpt":"<h3>类加载时机</h3>\\n<figure><figcaption>类加载的时机</figcaption></figure>\\n<p>加载、验证、准备、初始化 顺序是固定的</p>\\n<p>必须初始化5种情况</p>\\n<ul>\\n<li>遇到 new getstatic、invokestatic putstatic、4条指令</li>\\n<li>Reflect包进行反射时</li>\\n<li>初始化一个类，父类未初始化时</li>\\n<li>Main类</li>\\n<li>动态支持，解析结果REF_getstatic、REF_putstatic、REF_invokeStatic方法句柄</li>\\n</ul>","autoDesc":true}');export{k as comp,m as data};
