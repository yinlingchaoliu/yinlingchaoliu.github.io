import{_ as n}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as s,c as a,f as e}from"./app-CtvCwAmI.js";const t="/assets/binder_pool-BoQEPpZA.png",p={},i=e('<h3 id="binder池总结" tabindex="-1"><a class="header-anchor" href="#binder池总结"><span>binder池总结</span></a></h3><figure><img src="'+t+`" alt="binder线程池" tabindex="0" loading="lazy"><figcaption>binder线程池</figcaption></figure><p>每次由Zygote fork出新进程的过程中，伴随着创建binder线程池，调用spawnPooledThread来创建binder主线程。当线程执行binder_thread_read的过程中，发现当前没有空闲线程，没有请求创建线程，且没有达到上限，则创建新的binder线程。</p><p>Binder的transaction有3种类型：</p><ul><li>call: 发起进程的线程不一定是在Binder线程， 大多數情況下，接收者只指向进程，并不确定会有哪个线程来处理，所以不指定线程；</li><li>reply: 发起者一定是binder线程，并且接收者线程便是上次call时的发起线程(该线程不一定是binder线程，可以是任意线程)。</li><li>async: 与call类型差不多，唯一不同的是async是oneway方式不需要回复，发起进程的线程不一定是在Binder线程， 接收者只指向进程，并不确定会有哪个线程来处理，所以不指定线程。</li></ul><p>Binder系统中可分为3类binder线程：</p><ul><li>Binder主线程：进程创建过程会调用startThreadPool()过程中再进入spawnPooledThread(true)，来创建Binder主线程。编号从1开始，也就是意味着binder主线程名为binder_1，并且主线程是不会退出的。</li><li>Binder普通线程：是由Binder Driver来根据是否有空闲的binder线程来决定是否创建binder线程，回调spawnPooledThread(false) ，isMain=false，该线程名格式为binder_x。</li><li>Binder其他线程：其他线程是指并没有调用spawnPooledThread方法，而是直接调用IPC.joinThreadPool()，将当前线程直接加入binder线程队列。例如： mediaserver和servicemanager的主线程都是binder线程，但system_server的主线程并非binder线程。</li></ul><h3 id="binder线程创建" tabindex="-1"><a class="header-anchor" href="#binder线程创建"><span>Binder线程创建</span></a></h3><ol><li>Process.start() 向zygote进程发起创建socket消息</li><li>Zygote.forkAndSpecialize() fork新进程</li><li>新进程调用RuntimeInit.nativeZygoteInit 方法</li><li>jni映射调用c++方法 app_main.cpp中onZygoteInit</li><li>打开/dev/binder驱动设备</li><li>startThreadPool()是创建一个新的binder线程，不断进行talkWithDriver()</li></ol><h3 id="核心代码" tabindex="-1"><a class="header-anchor" href="#核心代码"><span>核心代码</span></a></h3><div class="language-c line-numbers-mode" data-ext="c" data-title="c"><pre class="language-c"><code>virtual <span class="token keyword">void</span> <span class="token function">onZygoteInit</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">//获取ProcessState对象</span>
    sp<span class="token operator">&lt;</span>ProcessState<span class="token operator">&gt;</span> proc <span class="token operator">=</span> ProcessState<span class="token operator">::</span><span class="token function">self</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//启动新binder线程 </span>
    proc<span class="token operator">-&gt;</span><span class="token function">startThreadPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>对于isMain=true的情况下， command为BC_ENTER_LOOPER，代表的是Binder主线程，不会退出的线程；</li><li>对于isMain=false的情况下，command为BC_REGISTER_LOOPER，表示是由binder驱动创建的线程。</li></ul><div class="language-c line-numbers-mode" data-ext="c" data-title="c"><pre class="language-c"><code>
<span class="token comment">//主binder池</span>
<span class="token keyword">void</span> ProcessState<span class="token operator">::</span><span class="token function">startThreadPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    AutoMutex <span class="token function">_l</span><span class="token punctuation">(</span>mLock<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//多线程同步</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>mThreadPoolStarted<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        mThreadPoolStarted <span class="token operator">=</span> true<span class="token punctuation">;</span>
        <span class="token function">spawnPooledThread</span><span class="token punctuation">(</span>true<span class="token punctuation">)</span><span class="token punctuation">;</span>  
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">//普通binder线程</span>
<span class="token class-name">status_t</span> IPCThreadState<span class="token operator">::</span><span class="token function">executeCommand</span><span class="token punctuation">(</span><span class="token class-name">int32_t</span> cmd<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token class-name">status_t</span> result <span class="token operator">=</span> NO_ERROR<span class="token punctuation">;</span>
    <span class="token keyword">switch</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">uint32_t</span><span class="token punctuation">)</span>cmd<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
      <span class="token keyword">case</span> BR_SPAWN_LOOPER<span class="token operator">:</span>
          <span class="token comment">//创建新的binder线程 【见小节2.3】</span>
          mProcess<span class="token operator">-&gt;</span><span class="token function">spawnPooledThread</span><span class="token punctuation">(</span>false<span class="token punctuation">)</span><span class="token punctuation">;</span>
          <span class="token keyword">break</span><span class="token punctuation">;</span>
      <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> result<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> ProcessState<span class="token operator">::</span><span class="token function">spawnPooledThread</span><span class="token punctuation">(</span>bool isMain<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>mThreadPoolStarted<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">//获取Binder线程名</span>
        String8 name <span class="token operator">=</span> <span class="token function">makeBinderThreadName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//此处isMain=true</span>
        sp<span class="token operator">&lt;</span>Thread<span class="token operator">&gt;</span> t <span class="token operator">=</span> new <span class="token function">PoolThread</span><span class="token punctuation">(</span>isMain<span class="token punctuation">)</span><span class="token punctuation">;</span>
        t<span class="token operator">-&gt;</span><span class="token function">run</span><span class="token punctuation">(</span>name<span class="token punctuation">.</span><span class="token function">string</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>


class PoolThread <span class="token operator">:</span> public Thread
<span class="token punctuation">{</span>
public<span class="token operator">:</span>
    <span class="token function">PoolThread</span><span class="token punctuation">(</span>bool isMain<span class="token punctuation">)</span>
        <span class="token operator">:</span> <span class="token function">mIsMain</span><span class="token punctuation">(</span>isMain<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
    <span class="token punctuation">}</span>

protected<span class="token operator">:</span>
    virtual bool <span class="token function">threadLoop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        IPCThreadState<span class="token operator">::</span><span class="token function">self</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span><span class="token function">joinThreadPool</span><span class="token punctuation">(</span>mIsMain<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//【见小节2.4】</span>
        <span class="token keyword">return</span> false<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">const</span> bool mIsMain<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>


<span class="token keyword">void</span> IPCThreadState<span class="token operator">::</span><span class="token function">joinThreadPool</span><span class="token punctuation">(</span>bool isMain<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment">//创建Binder线程</span>
    mOut<span class="token punctuation">.</span><span class="token function">writeInt32</span><span class="token punctuation">(</span>isMain <span class="token operator">?</span> BC_ENTER_LOOPER <span class="token operator">:</span> BC_REGISTER_LOOPER<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">set_sched_policy</span><span class="token punctuation">(</span>mMyThreadId<span class="token punctuation">,</span> SP_FOREGROUND<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//设置前台调度策略</span>

    <span class="token class-name">status_t</span> result<span class="token punctuation">;</span>
    <span class="token keyword">do</span> <span class="token punctuation">{</span>
        <span class="token function">processPendingDerefs</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//清除队列的引用[见小节2.5]</span>
        result <span class="token operator">=</span> <span class="token function">getAndExecuteCommand</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//处理下一条指令[见小节2.6]</span>

        <span class="token keyword">if</span> <span class="token punctuation">(</span>result <span class="token operator">&lt;</span> NO_ERROR <span class="token operator">&amp;&amp;</span> result <span class="token operator">!=</span> TIMED_OUT
                <span class="token operator">&amp;&amp;</span> result <span class="token operator">!=</span> <span class="token operator">-</span>ECONNREFUSED <span class="token operator">&amp;&amp;</span> result <span class="token operator">!=</span> <span class="token operator">-</span>EBADF<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">abort</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">if</span><span class="token punctuation">(</span>result <span class="token operator">==</span> TIMED_OUT <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>isMain<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span> <span class="token comment">////非主线程出现timeout则线程退出</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>result <span class="token operator">!=</span> <span class="token operator">-</span>ECONNREFUSED <span class="token operator">&amp;&amp;</span> result <span class="token operator">!=</span> <span class="token operator">-</span>EBADF<span class="token punctuation">)</span><span class="token punctuation">;</span>

    mOut<span class="token punctuation">.</span><span class="token function">writeInt32</span><span class="token punctuation">(</span>BC_EXIT_LOOPER<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 线程退出循环</span>
    <span class="token function">talkWithDriver</span><span class="token punctuation">(</span>false<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//false代表bwr数据的read_buffer为空</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>调用链 onZygoteInit-&gt;startThreadPool-&gt;spawnPooledThread-&gt;PoolThread-&gt;joinThreadPool-&gt;talkWithDriver</p><h3 id="binder池上限" tabindex="-1"><a class="header-anchor" href="#binder池上限"><span>binder池上限</span></a></h3><p>默认地，每个进程的binder线程池的线程个数上限为15，该上限不统计通过BC_ENTER_LOOPER命令创建的binder主线程， 只计算BC_REGISTER_LOOPER命令创建的线程。 对此，或者很多人不理解，例个栗子：某个进程的主线程执行如下方法，那么该进程可创建的binder线程个数上限是多少呢？</p><div class="language-c line-numbers-mode" data-ext="c" data-title="c"><pre class="language-c"><code>ProcessState<span class="token operator">::</span><span class="token function">self</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span><span class="token function">setThreadPoolMaxThreadCount</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 6个线程</span>
ProcessState<span class="token operator">::</span><span class="token function">self</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span><span class="token function">startThreadPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 1个线程</span>
IPCThread<span class="token operator">::</span><span class="token function">self</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span><span class="token function">joinThreadPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 1个线程</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol><li>binder池 可使用 6个</li><li>通过startThreadPool()创建的主线程不算在最大线程上限 1个</li><li>当前线程成为binder线程 1个</li><li>binder线程个数上限为8</li></ol><h3 id="binder-thread-read" tabindex="-1"><a class="header-anchor" href="#binder-thread-read"><span>binder_thread_read</span></a></h3><p>当发生以下3种情况之一，便会进入done：</p><ol><li>当前线程的return_error发生error的情况；</li><li>当Binder驱动向client端发送死亡通知的情况；</li><li>当类型为BINDER_WORK_TRANSACTION(即收到命令是BC_TRANSACTION或BC_REPLY)的情况；</li></ol><p>任何一个Binder线程当同时满足以下条件，则会生成用于创建新线程的BR_SPAWN_LOOPER命令：</p><ol><li>当前进程中没有请求创建binder线程，即requested_threads = 0；</li><li>当前进程没有空闲可用的binder线程，即ready_threads = 0；（线程进入休眠状态的个数就是空闲线程数）</li><li>当前进程已启动线程个数小于最大上限(默认15)；</li><li>当前线程已接收到BC_ENTER_LOOPER或者BC_REGISTER_LOOPER命令，即当前处于BINDER_LOOPER_STATE_REGISTERED或者BINDER_LOOPER_STATE_ENTERED状态。【小节2.6】已设置状态为BINDER_LOOPER_STATE_ENTERED，显然这条件是满足的</li></ol><h3 id="代码路径" tabindex="-1"><a class="header-anchor" href="#代码路径"><span>代码路径</span></a></h3><div class="language-markdown line-numbers-mode" data-ext="md" data-title="md"><pre class="language-markdown"><code>frameworks/base/cmds/app_process/app_main.cpp
frameworks/native/libs/binder/ProcessState.cpp
framework/native/libs/binder/IPCThreadState.cpp
kernel/drivers/staging/android/binder.c
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,25),o=[i];function l(c,r){return s(),a("div",null,o)}const k=n(p,[["render",l],["__file","启动binder线程池.html.vue"]]),m=JSON.parse('{"path":"/fe/framework/binder/%E5%90%AF%E5%8A%A8binder%E7%BA%BF%E7%A8%8B%E6%B1%A0.html","title":"启动binder线程池","lang":"zh-CN","frontmatter":{"title":"启动binder线程池","date":"2024-04-14T11:47:50.000Z","order":5,"category":["framework"],"tag":["binder"],"description":"binder池总结 binder线程池binder线程池 每次由Zygote fork出新进程的过程中，伴随着创建binder线程池，调用spawnPooledThread来创建binder主线程。当线程执行binder_thread_read的过程中，发现当前没有空闲线程，没有请求创建线程，且没有达到上限，则创建新的binder线程。 Binder的...","head":[["meta",{"property":"og:url","content":"https://yinlingchaoliu.github.io/fe/framework/binder/%E5%90%AF%E5%8A%A8binder%E7%BA%BF%E7%A8%8B%E6%B1%A0.html"}],["meta",{"property":"og:site_name","content":"引领潮流"}],["meta",{"property":"og:title","content":"启动binder线程池"}],["meta",{"property":"og:description","content":"binder池总结 binder线程池binder线程池 每次由Zygote fork出新进程的过程中，伴随着创建binder线程池，调用spawnPooledThread来创建binder主线程。当线程执行binder_thread_read的过程中，发现当前没有空闲线程，没有请求创建线程，且没有达到上限，则创建新的binder线程。 Binder的..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-04-22T23:46:25.000Z"}],["meta",{"property":"article:author","content":"引领潮流"}],["meta",{"property":"article:tag","content":"binder"}],["meta",{"property":"article:published_time","content":"2024-04-14T11:47:50.000Z"}],["meta",{"property":"article:modified_time","content":"2024-04-22T23:46:25.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"启动binder线程池\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-04-14T11:47:50.000Z\\",\\"dateModified\\":\\"2024-04-22T23:46:25.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"引领潮流\\",\\"url\\":\\"https://www.jianshu.com/u/bdcce32c05dd\\"}]}"]]},"headers":[{"level":3,"title":"binder池总结","slug":"binder池总结","link":"#binder池总结","children":[]},{"level":3,"title":"Binder线程创建","slug":"binder线程创建","link":"#binder线程创建","children":[]},{"level":3,"title":"核心代码","slug":"核心代码","link":"#核心代码","children":[]},{"level":3,"title":"binder池上限","slug":"binder池上限","link":"#binder池上限","children":[]},{"level":3,"title":"binder_thread_read","slug":"binder-thread-read","link":"#binder-thread-read","children":[]},{"level":3,"title":"代码路径","slug":"代码路径","link":"#代码路径","children":[]}],"git":{"createdTime":1713767054000,"updatedTime":1713829585000,"contributors":[{"name":"引领潮流","email":"heat13@qq.com","commits":2}]},"readingTime":{"minutes":4.16,"words":1247},"filePathRelative":"fe/framework/binder/启动binder线程池.md","localizedDate":"2024年4月14日","excerpt":"<h3>binder池总结</h3>\\n<figure><figcaption>binder线程池</figcaption></figure>\\n<p>每次由Zygote fork出新进程的过程中，伴随着创建binder线程池，调用spawnPooledThread来创建binder主线程。当线程执行binder_thread_read的过程中，发现当前没有空闲线程，没有请求创建线程，且没有达到上限，则创建新的binder线程。</p>\\n<p>Binder的transaction有3种类型：</p>\\n<ul>\\n<li>call: 发起进程的线程不一定是在Binder线程， 大多數情況下，接收者只指向进程，并不确定会有哪个线程来处理，所以不指定线程；</li>\\n<li>reply: 发起者一定是binder线程，并且接收者线程便是上次call时的发起线程(该线程不一定是binder线程，可以是任意线程)。</li>\\n<li>async: 与call类型差不多，唯一不同的是async是oneway方式不需要回复，发起进程的线程不一定是在Binder线程， 接收者只指向进程，并不确定会有哪个线程来处理，所以不指定线程。</li>\\n</ul>","autoDesc":true}');export{k as comp,m as data};
